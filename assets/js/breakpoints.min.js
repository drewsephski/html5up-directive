/* breakpoints.js v1.0 | @ajlkn | MIT licensed */
/**
 * A utility for managing responsive breakpoints and media queries.
 *
 * @module breakpoints
 * @version 1.0
 * @author @ajlkn
 * @license MIT
 */

var breakpoints = (function () {
    "use strict";

    /**
     * Initializes the breakpoints utility with a list of breakpoints.
     *
     * @param {Object} list - An object containing breakpoint names as keys and their corresponding values.
     * @example
     * var breakpointsList = {
     *     'small': ['480px', '767px'],
     *     'medium': ['768px', '991px'],
     *     'large': ['992px', '1199px'],
     *     'extra-large': ['1200px']
     * };
     * breakpoints.init(breakpointsList);
     */
    function init(list) {
        t.list = list;
        window.addEventListener("resize", t.poll);
        window.addEventListener("orientationchange", t.poll);
        window.addEventListener("load", t.poll);
        window.addEventListener("fullscreenchange", t.poll);
    }

    var t = {
        list: null,
        media: {},
        events: [],

        init: init,

        /**
         * Checks if a given breakpoint is currently active.
         *
         * @param {string} query - The name of the breakpoint to check.
         * @returns {boolean} - True if the breakpoint is active, false otherwise.
         */
        active: function (query) {
            var n, a, s, i, r, d, c;

            if (!(query in t.media)) {
                // Parse the query to determine the comparison operator and breakpoint name
                if (">=" == query.substr(0, 2)) {
                    a = "gte";
                    n = query.substr(2);
                } else if ("<=" == query.substr(0, 2)) {
                    a = "lte";
                    n = query.substr(2);
                } else if (">" == query.substr(0, 1)) {
                    a = "gt";
                    n = query.substr(1);
                } else if ("<" == query.substr(0, 1)) {
                    a = "lt";
                    n = query.substr(1);
                } else if ("!" == query.substr(0, 1)) {
                    a = "not";
                    n = query.substr(1);
                } else {
                    a = "eq";
                    n = query;
                }

                // Check if the breakpoint name exists in the list
                if (n && n in t.list) {
                    i = t.list[n];

                    // Handle array values for the breakpoint
                    if (Array.isArray(i)) {
                        r = parseInt(i[0]);
                        d = parseInt(i[1]);

                        // Determine the unit for the breakpoint values
                        if (isNaN(r)) {
                            if (isNaN(d)) {
                                return;
                            }
                            c = i[1].substr(String(d).length);
                        } else {
                            c = i[0].substr(String(r).length);
                        }

                        // Generate the media query string based on the comparison operator
                        if (isNaN(r)) {
                            switch (a) {
                                case "gte":
                                    s = "screen";
                                    break;
                                case "lte":
                                    s = "screen and (max-width: " + d + c + ")";
                                    break;
                                case "gt":
                                    s = "screen and (min-width: " + (d + 1) + c + ")";
                                    break;
                                case "lt":
                                    s = "screen and (max-width: -1px)";
                                    break;
                                case "not":
                                    s = "screen and (min-width: " + (d + 1) + c + ")";
                                    break;
                                default:
                                    s = "screen and (max-width: " + d + c + ")";
                            }
                        } else if (isNaN(d)) {
                            switch (a) {
                                case "gte":
                                    s = "screen and (min-width: " + r + c + ")";
                                    break;
                                case "lte":
                                    s = "screen";
                                    break;
                                case "gt":
                                    s = "screen and (max-width: -1px)";
                                    break;
                                case "lt":
                                    s = "screen and (max-width: " + (r - 1) + c + ")";
                                    break;
                                case "not":
                                    s = "screen and (max-width: " + (r - 1) + c + ")";
                                    break;
                                default:
                                    s = "screen and (min-width: " + r + c + ")";
                            }
                        } else {
                            switch (a) {
                                case "gte":
                                    s = "screen and (min-width: " + r + c + ")";
                                    break;
                                case "lte":
                                    s = "screen and (max-width: " + d + c + ")";
                                    break;
                                case "gt":
                                    s = "screen and (min-width: " + (d + 1) + c + ")";
                                    break;
                                case "lt":
                                    s = "screen and (max-width: " + (r - 1) + c + ")";
                                    break;
                                case "not":
                                    s = "screen and (max-width: " + (r - 1) + c + "), screen and (min-width: " + (d + 1) + c + ")";
                                    break;
                                default:
                                    s = "screen and (min-width: " + r + c + ") and (max-width: " + d + c + ")";
                            }
                        }
                    } else {
                        s = "(" == i.charAt(0) ? "screen and " + i : i;
                    }

                    // Store the media query string in the media object
                    t.media[query] = !!s && s;
                }
            }

            // Return whether the breakpoint is active
            return t.media[query] !== !1 && window.matchMedia(t.media[query]).matches;
        },

        /**
         * Registers an event handler for a specific breakpoint.
         *
         * @param {string} query - The name of the breakpoint to listen for.
         * @param {function} handler - The event handler function to be called when the breakpoint is activated or deactivated.
         */
        on: function (query, handler) {
            t.events.push({ query: query, handler: handler, state: !1 });
            t.active(query) && handler();
        },

        /**
         * Polls the current state of all registered breakpoints.
         */
        poll: function () {
            var e, n;
            for (e = 0; e < t.events.length; e++) {
                n = t.events[e];
                t.active(n.query) ? n.state || (n.state = !0, n.handler()) : n.state && (n.state = !1);
            }
        }
    };

    return {
        _: t,
        on: function (query, handler) {
            t.on(query, handler);
        },
        active: function (query) {
            return t.active(query);
        }
    };
})();

!function (e, t) {
    "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? module.exports = t() : e.breakpoints = t();
}(this, function () {
    return breakpoints;
});